use axum::{http::StatusCode, response::IntoResponse, Json};
use opensearch::OpenSearch;
use serde_json::json;
use sqlx::postgres::PgPool;
use thiserror::Error;

pub struct AppState {
    pub opensearch: OpenSearch,
    pub pool: PgPool,
}

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Resource not found")]
    NotFound,

    #[error(transparent)]
    Other(#[from] anyhow::Error),
}

impl IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        // Get the error message from Display impl generated by thiserror
        let error_message = self.to_string();

        // Map error types to status codes
        let status = match &self {
            AppError::NotFound { .. } => StatusCode::NOT_FOUND,
            AppError::Other { .. } => StatusCode::INTERNAL_SERVER_ERROR,
        };

        // Create an error response JSON structure
        let body = Json(json!({
            "error": {
                "message": error_message,
                "code": status.as_u16(),
            }
        }));

        (status, body).into_response()
    }
}
